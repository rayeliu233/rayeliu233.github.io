{"ast":null,"code":"import * as n from \"react\";\n\nfunction t() {\n  return (t = Object.assign || function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (n[e] = r[e]);\n    }\n\n    return n;\n  }).apply(this, arguments);\n}\n\nvar r = [\"children\", \"options\"],\n    e = [\"allowFullScreen\", \"allowTransparency\", \"autoComplete\", \"autoFocus\", \"autoPlay\", \"cellPadding\", \"cellSpacing\", \"charSet\", \"className\", \"classId\", \"colSpan\", \"contentEditable\", \"contextMenu\", \"crossOrigin\", \"encType\", \"formAction\", \"formEncType\", \"formMethod\", \"formNoValidate\", \"formTarget\", \"frameBorder\", \"hrefLang\", \"inputMode\", \"keyParams\", \"keyType\", \"marginHeight\", \"marginWidth\", \"maxLength\", \"mediaGroup\", \"minLength\", \"noValidate\", \"radioGroup\", \"readOnly\", \"rowSpan\", \"spellCheck\", \"srcDoc\", \"srcLang\", \"srcSet\", \"tabIndex\", \"useMap\"].reduce(function (n, t) {\n  return n[t.toLowerCase()] = t, n;\n}, {\n  for: \"htmlFor\"\n}),\n    o = {\n  amp: \"&\",\n  apos: \"'\",\n  gt: \">\",\n  lt: \"<\",\n  nbsp: \" \",\n  quot: \"“\"\n},\n    u = [\"style\", \"script\"],\n    a = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi,\n    c = /mailto:/i,\n    i = /\\n{2,}$/,\n    f = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/,\n    l = /^ *> ?/gm,\n    s = /^ {2,}\\n/,\n    _ = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/,\n    d = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/,\n    p = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/,\n    g = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n    m = /^(?:\\n *)*\\n/,\n    v = /\\r\\n?/g,\n    y = /^\\[\\^([^\\]]+)](:.*)\\n/,\n    h = /^\\[\\^([^\\]]+)]/,\n    k = /\\f/g,\n    x = /^\\s*?\\[(x|\\s)\\]/,\n    b = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/,\n    S = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/,\n    $ = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i,\n    w = /&([a-z]+);/g,\n    z = /^<!--[\\s\\S]*?(?:-->)/,\n    E = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/,\n    A = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i,\n    R = /^\\{.*\\}$/,\n    I = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n    M = /^<([^ >]+@[^ >]+)>/,\n    O = /^<([^ >]+:\\/[^ >]+)>/,\n    B = / *\\n+$/,\n    L = /(?:^|\\n)( *)$/,\n    T = /-([a-z])?/gi,\n    j = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/,\n    C = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/,\n    D = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n    N = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/,\n    Z = /(\\[|\\])/g,\n    F = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/,\n    P = /\\t/g,\n    G = /^ *\\| */,\n    H = /(^ *\\||\\| *$)/g,\n    q = / *$/,\n    U = /^ *:-+: *$/,\n    V = /^ *:-+ *$/,\n    W = /^ *-+: *$/,\n    Q = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/,\n    X = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/,\n    J = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/,\n    K = /^\\\\([^0-9A-Za-z\\s])/,\n    Y = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i,\n    nn = /^\\n+/,\n    tn = /^([ \\t]*)/,\n    rn = /\\\\([^0-9A-Z\\s])/gi,\n    en = new RegExp(\"^( *)((?:[*+-]|\\\\d+\\\\.)) +\"),\n    on = new RegExp(\"^( *)((?:[*+-]|\\\\d+\\\\.)) +[^\\\\n]*(?:\\\\n(?!\\\\1(?:[*+-]|\\\\d+\\\\.) )[^\\\\n]*)*(\\\\n|$)\", \"gm\"),\n    un = new RegExp(\"^( *)((?:[*+-]|\\\\d+\\\\.)) [\\\\s\\\\S]+?(?:\\\\n{2,}(?! )(?!\\\\1(?:[*+-]|\\\\d+\\\\.) (?!(?:[*+-]|\\\\d+\\\\.) ))\\\\n*|\\\\s*\\\\n*$)\"),\n    an = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\",\n    cn = new RegExp(\"^\\\\[(\" + an + \")\\\\]\\\\(\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\\\\)\"),\n    fn = new RegExp(\"^!\\\\[(\" + an + \")\\\\]\\\\(\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\\\\)\"),\n    ln = [f, p, d, b, S, z, on, un, j],\n    sn = [].concat(ln, [/^[^\\n]+(?:  \\n|\\n{2,})/, $, A]);\n\nfunction _n(n) {\n  return n.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, \"a\").replace(/[çÇ]/g, \"c\").replace(/[ðÐ]/g, \"d\").replace(/[ÈÉÊËéèêë]/g, \"e\").replace(/[ÏïÎîÍíÌì]/g, \"i\").replace(/[Ññ]/g, \"n\").replace(/[øØœŒÕõÔôÓóÒò]/g, \"o\").replace(/[ÜüÛûÚúÙù]/g, \"u\").replace(/[ŸÿÝý]/g, \"y\").replace(/[^a-z0-9- ]/gi, \"\").replace(/ /gi, \"-\").toLowerCase();\n}\n\nfunction dn(n) {\n  return W.test(n) ? \"right\" : U.test(n) ? \"center\" : V.test(n) ? \"left\" : null;\n}\n\nfunction pn(n, t, r) {\n  var e = r.t;\n  r.t = !0;\n  var o = t(n.trim(), r);\n  r.t = e;\n  var u = [[]];\n  return o.forEach(function (n, t) {\n    \"tableSeparator\" === n.type ? 0 !== t && t !== o.length - 1 && u.push([]) : (\"text\" !== n.type || null != o[t + 1] && \"tableSeparator\" !== o[t + 1].type || (n.content = n.content.replace(q, \"\")), u[u.length - 1].push(n));\n  }), u;\n}\n\nfunction gn(n, t, r) {\n  r.o = !0;\n\n  var e = pn(n[1], t, r),\n      o = n[2].replace(H, \"\").split(\"|\").map(dn),\n      u = function (n, t, r) {\n    return n.trim().split(\"\\n\").map(function (n) {\n      return pn(n, t, r);\n    });\n  }(n[3], t, r);\n\n  return r.o = !1, {\n    align: o,\n    cells: u,\n    header: e,\n    type: \"table\"\n  };\n}\n\nfunction mn(n, t) {\n  return null == n.align[t] ? {} : {\n    textAlign: n.align[t]\n  };\n}\n\nfunction vn(n) {\n  return function (t, r) {\n    return r.o ? n.exec(t) : null;\n  };\n}\n\nfunction yn(n) {\n  return function (t, r) {\n    return r.o || r.u ? n.exec(t) : null;\n  };\n}\n\nfunction hn(n) {\n  return function (t, r) {\n    return r.o || r.u ? null : n.exec(t);\n  };\n}\n\nfunction kn(n) {\n  return function (t) {\n    return n.exec(t);\n  };\n}\n\nfunction xn(n, t, r) {\n  if (t.o || t.u) return null;\n  if (r && !r.endsWith(\"\\n\")) return null;\n  var e = \"\";\n  n.split(\"\\n\").every(function (n) {\n    return !ln.some(function (t) {\n      return t.test(n);\n    }) && (e += n + \"\\n\", n.trim());\n  });\n  var o = e.trimEnd();\n  return \"\" == o ? null : [e, o];\n}\n\nfunction bn(n) {\n  try {\n    if (decodeURIComponent(n).replace(/[^A-Za-z0-9/:]/g, \"\").match(/^\\s*(javascript|vbscript|data):/i)) return null;\n  } catch (n) {\n    return null;\n  }\n\n  return n;\n}\n\nfunction Sn(n) {\n  return n.replace(rn, \"$1\");\n}\n\nfunction $n(n, t, r) {\n  var e = r.o || !1,\n      o = r.u || !1;\n  r.o = !0, r.u = !0;\n  var u = n(t, r);\n  return r.o = e, r.u = o, u;\n}\n\nfunction wn(n, t, r) {\n  var e = r.o || !1,\n      o = r.u || !1;\n  r.o = !1, r.u = !0;\n  var u = n(t, r);\n  return r.o = e, r.u = o, u;\n}\n\nfunction zn(n, t, r) {\n  return r.o = !1, n(t + \"\\n\\n\", r);\n}\n\nvar En,\n    An = function (n, t, r) {\n  return {\n    content: $n(t, n[1], r)\n  };\n};\n\nfunction Rn() {\n  return {};\n}\n\nfunction In() {\n  return null;\n}\n\nfunction Mn() {\n  return [].slice.call(arguments).filter(Boolean).join(\" \");\n}\n\nfunction On(n, t, r) {\n  for (var e = n, o = t.split(\".\"); o.length && void 0 !== (e = e[o[0]]);) o.shift();\n\n  return e || r;\n}\n\nfunction Bn(n, t) {\n  var r = On(t, n);\n  return r ? \"function\" == typeof r || \"object\" == typeof r && \"render\" in r ? r : On(t, n + \".component\", n) : n;\n}\n\nfunction Ln(r, H) {\n  void 0 === H && (H = {}), H.overrides = H.overrides || {}, H.slugify = H.slugify || _n, H.namedCodesToUnicode = H.namedCodesToUnicode ? t({}, o, H.namedCodesToUnicode) : o;\n  var q = H.createElement || n.createElement;\n\n  function U(n, r) {\n    var e = On(H.overrides, n + \".props\", {});\n    return q.apply(void 0, [Bn(n, H.overrides), t({}, r, e, {\n      className: Mn(null == r ? void 0 : r.className, e.className) || void 0\n    })].concat([].slice.call(arguments, 2)));\n  }\n\n  function V(t) {\n    var r = !1;\n    H.forceInline ? r = !0 : H.forceBlock || (r = !1 === F.test(t));\n\n    for (var e = Ln(pn(r ? t : t.trimEnd().replace(nn, \"\") + \"\\n\\n\", {\n      o: r\n    })); \"string\" == typeof e[e.length - 1] && !e[e.length - 1].trim();) e.pop();\n\n    if (null === H.wrapper) return e;\n    var o,\n        u = H.wrapper || (r ? \"span\" : \"div\");\n    if (e.length > 1 || H.forceWrapper) o = e;else {\n      if (1 === e.length) return \"string\" == typeof (o = e[0]) ? U(\"span\", {\n        key: \"outer\"\n      }, o) : o;\n      o = null;\n    }\n    return n.createElement(u, {\n      key: \"outer\"\n    }, o);\n  }\n\n  function W(t) {\n    var r = t.match(a);\n    return r ? r.reduce(function (t, r, o) {\n      var u = r.indexOf(\"=\");\n\n      if (-1 !== u) {\n        var a = function (n) {\n          return -1 !== n.indexOf(\"-\") && null === n.match(E) && (n = n.replace(T, function (n, t) {\n            return t.toUpperCase();\n          })), n;\n        }(r.slice(0, u)).trim(),\n            c = function (n) {\n          var t = n[0];\n          return ('\"' === t || \"'\" === t) && n.length >= 2 && n[n.length - 1] === t ? n.slice(1, -1) : n;\n        }(r.slice(u + 1).trim()),\n            i = e[a] || a,\n            f = t[i] = function (n, t) {\n          return \"style\" === n ? t.split(/;\\s?/).reduce(function (n, t) {\n            var r = t.slice(0, t.indexOf(\":\"));\n            return n[r.replace(/(-[a-z])/g, function (n) {\n              return n[1].toUpperCase();\n            })] = t.slice(r.length + 1).trim(), n;\n          }, {}) : \"href\" === n ? bn(t) : (t.match(R) && (t = t.slice(1, t.length - 1)), \"true\" === t || \"false\" !== t && t);\n        }(a, c);\n\n        \"string\" == typeof f && ($.test(f) || A.test(f)) && (t[i] = n.cloneElement(V(f.trim()), {\n          key: o\n        }));\n      } else \"style\" !== r && (t[e[r] || r] = !0);\n\n      return t;\n    }, {}) : void 0;\n  }\n\n  var rn = [],\n      an = {},\n      ln = {\n    blockQuote: {\n      i: hn(f),\n      l: En.HIGH,\n      _: function (n, t, r) {\n        return {\n          content: t(n[0].replace(l, \"\"), r)\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"blockquote\", {\n          key: r.g\n        }, t(n.content, r));\n      }\n    },\n    breakLine: {\n      i: kn(s),\n      l: En.HIGH,\n      _: Rn,\n      p: function (n, t, r) {\n        return U(\"br\", {\n          key: r.g\n        });\n      }\n    },\n    breakThematic: {\n      i: hn(_),\n      l: En.HIGH,\n      _: Rn,\n      p: function (n, t, r) {\n        return U(\"hr\", {\n          key: r.g\n        });\n      }\n    },\n    codeBlock: {\n      i: hn(p),\n      l: En.MAX,\n      _: function (n) {\n        return {\n          content: n[0].replace(/^ {4}/gm, \"\").replace(/\\n+$/, \"\"),\n          lang: void 0\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"pre\", {\n          key: r.g\n        }, U(\"code\", {\n          className: n.lang ? \"lang-\" + n.lang : \"\"\n        }, n.content));\n      }\n    },\n    codeFenced: {\n      i: hn(d),\n      l: En.MAX,\n      _: function (n) {\n        return {\n          content: n[3],\n          lang: n[2] || void 0,\n          type: \"codeBlock\"\n        };\n      }\n    },\n    codeInline: {\n      i: yn(g),\n      l: En.LOW,\n      _: function (n) {\n        return {\n          content: n[2]\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"code\", {\n          key: r.g\n        }, n.content);\n      }\n    },\n    footnote: {\n      i: hn(y),\n      l: En.MAX,\n      _: function (n) {\n        return rn.push({\n          footnote: n[2],\n          identifier: n[1]\n        }), {};\n      },\n      p: In\n    },\n    footnoteReference: {\n      i: vn(h),\n      l: En.HIGH,\n      _: function (n) {\n        return {\n          content: n[1],\n          target: \"#\" + H.slugify(n[1])\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"a\", {\n          key: r.g,\n          href: bn(n.target)\n        }, U(\"sup\", {\n          key: r.g\n        }, n.content));\n      }\n    },\n    gfmTask: {\n      i: vn(x),\n      l: En.HIGH,\n      _: function (n) {\n        return {\n          completed: \"x\" === n[1].toLowerCase()\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"input\", {\n          checked: n.completed,\n          key: r.g,\n          readOnly: !0,\n          type: \"checkbox\"\n        });\n      }\n    },\n    heading: {\n      i: hn(b),\n      l: En.HIGH,\n      _: function (n, t, r) {\n        return {\n          content: $n(t, n[2], r),\n          id: H.slugify(n[2]),\n          level: n[1].length\n        };\n      },\n      p: function (n, t, r) {\n        return n.tag = \"h\" + n.level, U(n.tag, {\n          id: n.id,\n          key: r.g\n        }, t(n.content, r));\n      }\n    },\n    headingSetext: {\n      i: hn(S),\n      l: En.MAX,\n      _: function (n, t, r) {\n        return {\n          content: $n(t, n[1], r),\n          level: \"=\" === n[2] ? 1 : 2,\n          type: \"heading\"\n        };\n      }\n    },\n    htmlComment: {\n      i: kn(z),\n      l: En.HIGH,\n      _: function () {\n        return {};\n      },\n      p: In\n    },\n    image: {\n      i: yn(fn),\n      l: En.HIGH,\n      _: function (n) {\n        return {\n          alt: n[1],\n          target: Sn(n[2]),\n          title: n[3]\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"img\", {\n          key: r.g,\n          alt: n.alt || void 0,\n          title: n.title || void 0,\n          src: bn(n.target)\n        });\n      }\n    },\n    link: {\n      i: vn(cn),\n      l: En.LOW,\n      _: function (n, t, r) {\n        return {\n          content: wn(t, n[1], r),\n          target: Sn(n[2]),\n          title: n[3]\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"a\", {\n          key: r.g,\n          href: bn(n.target),\n          title: n.title\n        }, t(n.content, r));\n      }\n    },\n    linkAngleBraceStyleDetector: {\n      i: vn(O),\n      l: En.MAX,\n      _: function (n) {\n        return {\n          content: [{\n            content: n[1],\n            type: \"text\"\n          }],\n          target: n[1],\n          type: \"link\"\n        };\n      }\n    },\n    linkBareUrlDetector: {\n      i: function (n, t) {\n        return t.m ? null : vn(I)(n, t);\n      },\n      l: En.MAX,\n      _: function (n) {\n        return {\n          content: [{\n            content: n[1],\n            type: \"text\"\n          }],\n          target: n[1],\n          title: void 0,\n          type: \"link\"\n        };\n      }\n    },\n    linkMailtoDetector: {\n      i: vn(M),\n      l: En.MAX,\n      _: function (n) {\n        var t = n[1],\n            r = n[1];\n        return c.test(r) || (r = \"mailto:\" + r), {\n          content: [{\n            content: t.replace(\"mailto:\", \"\"),\n            type: \"text\"\n          }],\n          target: r,\n          type: \"link\"\n        };\n      }\n    },\n    list: {\n      i: function (n, t, r) {\n        var e = L.exec(r);\n        return !e || !t.v && t.o ? null : un.exec(n = e[1] + n);\n      },\n      l: En.HIGH,\n      _: function (n, t, r) {\n        var e = n[2],\n            o = e.length > 1,\n            u = o ? +e : void 0,\n            a = n[0].replace(i, \"\\n\").match(on),\n            c = !1;\n        return {\n          items: a.map(function (n, e) {\n            var o = en.exec(n)[0].length,\n                u = new RegExp(\"^ {1,\" + o + \"}\", \"gm\"),\n                i = n.replace(u, \"\").replace(en, \"\"),\n                f = e === a.length - 1,\n                l = -1 !== i.indexOf(\"\\n\\n\") || f && c;\n            c = l;\n            var s,\n                _ = r.o,\n                d = r.v;\n            r.v = !0, l ? (r.o = !1, s = i.replace(B, \"\\n\\n\")) : (r.o = !0, s = i.replace(B, \"\"));\n            var p = t(s, r);\n            return r.o = _, r.v = d, p;\n          }),\n          ordered: o,\n          start: u\n        };\n      },\n      p: function (n, t, r) {\n        return U(n.ordered ? \"ol\" : \"ul\", {\n          key: r.g,\n          start: n.start\n        }, n.items.map(function (n, e) {\n          return U(\"li\", {\n            key: e\n          }, t(n, r));\n        }));\n      }\n    },\n    newlineCoalescer: {\n      i: hn(m),\n      l: En.LOW,\n      _: Rn,\n      p: function () {\n        return \"\\n\";\n      }\n    },\n    paragraph: {\n      i: xn,\n      l: En.LOW,\n      _: An,\n      p: function (n, t, r) {\n        return U(\"p\", {\n          key: r.g\n        }, t(n.content, r));\n      }\n    },\n    ref: {\n      i: vn(C),\n      l: En.MAX,\n      _: function (n) {\n        return an[n[1]] = {\n          target: n[2],\n          title: n[4]\n        }, {};\n      },\n      p: In\n    },\n    refImage: {\n      i: yn(D),\n      l: En.MAX,\n      _: function (n) {\n        return {\n          alt: n[1] || void 0,\n          ref: n[2]\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"img\", {\n          key: r.g,\n          alt: n.alt,\n          src: bn(an[n.ref].target),\n          title: an[n.ref].title\n        });\n      }\n    },\n    refLink: {\n      i: vn(N),\n      l: En.MAX,\n      _: function (n, t, r) {\n        return {\n          content: t(n[1], r),\n          fallbackContent: t(n[0].replace(Z, \"\\\\$1\"), r),\n          ref: n[2]\n        };\n      },\n      p: function (n, t, r) {\n        return an[n.ref] ? U(\"a\", {\n          key: r.g,\n          href: bn(an[n.ref].target),\n          title: an[n.ref].title\n        }, t(n.content, r)) : U(\"span\", {\n          key: r.g\n        }, t(n.fallbackContent, r));\n      }\n    },\n    table: {\n      i: hn(j),\n      l: En.HIGH,\n      _: gn,\n      p: function (n, t, r) {\n        return U(\"table\", {\n          key: r.g\n        }, U(\"thead\", null, U(\"tr\", null, n.header.map(function (e, o) {\n          return U(\"th\", {\n            key: o,\n            style: mn(n, o)\n          }, t(e, r));\n        }))), U(\"tbody\", null, n.cells.map(function (e, o) {\n          return U(\"tr\", {\n            key: o\n          }, e.map(function (e, o) {\n            return U(\"td\", {\n              key: o,\n              style: mn(n, o)\n            }, t(e, r));\n          }));\n        })));\n      }\n    },\n    tableSeparator: {\n      i: function (n, t) {\n        return t.t ? G.exec(n) : null;\n      },\n      l: En.HIGH,\n      _: function () {\n        return {\n          type: \"tableSeparator\"\n        };\n      },\n      p: function () {\n        return \" | \";\n      }\n    },\n    text: {\n      i: kn(Y),\n      l: En.MIN,\n      _: function (n) {\n        return {\n          content: n[0].replace(w, function (n, t) {\n            return H.namedCodesToUnicode[t] ? H.namedCodesToUnicode[t] : n;\n          })\n        };\n      },\n      p: function (n) {\n        return n.content;\n      }\n    },\n    textBolded: {\n      i: yn(Q),\n      l: En.MED,\n      _: function (n, t, r) {\n        return {\n          content: t(n[2], r)\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"strong\", {\n          key: r.g\n        }, t(n.content, r));\n      }\n    },\n    textEmphasized: {\n      i: yn(X),\n      l: En.LOW,\n      _: function (n, t, r) {\n        return {\n          content: t(n[2], r)\n        };\n      },\n      p: function (n, t, r) {\n        return U(\"em\", {\n          key: r.g\n        }, t(n.content, r));\n      }\n    },\n    textEscaped: {\n      i: yn(K),\n      l: En.HIGH,\n      _: function (n) {\n        return {\n          content: n[1],\n          type: \"text\"\n        };\n      }\n    },\n    textStrikethroughed: {\n      i: yn(J),\n      l: En.LOW,\n      _: An,\n      p: function (n, t, r) {\n        return U(\"del\", {\n          key: r.g\n        }, t(n.content, r));\n      }\n    }\n  };\n  !0 !== H.disableParsingRawHTML && (ln.htmlBlock = {\n    i: kn($),\n    l: En.HIGH,\n    _: function (n, t, r) {\n      var e,\n          o = n[3].match(tn),\n          a = new RegExp(\"^\" + o[1], \"gm\"),\n          c = n[3].replace(a, \"\"),\n          i = (e = c, sn.some(function (n) {\n        return n.test(e);\n      }) ? zn : $n),\n          f = n[1].toLowerCase(),\n          l = -1 !== u.indexOf(f);\n      r.m = r.m || \"a\" === f;\n      var s = l ? n[3] : i(t, c, r);\n      return r.m = !1, {\n        attrs: W(n[2]),\n        content: s,\n        noInnerParse: l,\n        tag: l ? f : n[1]\n      };\n    },\n    p: function (n, r, e) {\n      return U(n.tag, t({\n        key: e.g\n      }, n.attrs), n.noInnerParse ? n.content : r(n.content, e));\n    }\n  }, ln.htmlSelfClosing = {\n    i: kn(A),\n    l: En.HIGH,\n    _: function (n) {\n      return {\n        attrs: W(n[2] || \"\"),\n        tag: n[1]\n      };\n    },\n    p: function (n, r, e) {\n      return U(n.tag, t({}, n.attrs, {\n        key: e.g\n      }));\n    }\n  });\n\n  var dn,\n      pn = function (n) {\n    var t = Object.keys(n);\n\n    function r(e, o) {\n      for (var u = [], a = \"\"; e;) for (var c = 0; c < t.length;) {\n        var i = t[c],\n            f = n[i],\n            l = f.i(e, o, a);\n\n        if (l) {\n          var s = l[0];\n          e = e.substring(s.length);\n\n          var _ = f._(l, r, o);\n\n          null == _.type && (_.type = i), u.push(_), a = s;\n          break;\n        }\n\n        c++;\n      }\n\n      return u;\n    }\n\n    return t.sort(function (t, r) {\n      var e = n[t].l,\n          o = n[r].l;\n      return e !== o ? e - o : t < r ? -1 : 1;\n    }), function (n, t) {\n      return r(function (n) {\n        return n.replace(v, \"\\n\").replace(k, \"\").replace(P, \"    \");\n      }(n), t);\n    };\n  }(ln),\n      Ln = (dn = function (n) {\n    return function (t, r, e) {\n      return n[t.type].p(t, r, e);\n    };\n  }(ln), function n(t, r) {\n    if (void 0 === r && (r = {}), Array.isArray(t)) {\n      for (var e = r.g, o = [], u = !1, a = 0; a < t.length; a++) {\n        r.g = a;\n        var c = n(t[a], r),\n            i = \"string\" == typeof c;\n        i && u ? o[o.length - 1] += c : null !== c && o.push(c), u = i;\n      }\n\n      return r.g = e, o;\n    }\n\n    return dn(t, n, r);\n  }),\n      Tn = V(r);\n\n  return rn.length ? U(\"div\", null, Tn, U(\"footer\", {\n    key: \"footer\"\n  }, rn.map(function (n) {\n    return U(\"div\", {\n      id: H.slugify(n.identifier),\n      key: n.identifier\n    }, n.identifier, Ln(pn(n.footnote, {\n      o: !0\n    })));\n  }))) : Tn;\n}\n\n!function (n) {\n  n[n.MAX = 0] = \"MAX\", n[n.HIGH = 1] = \"HIGH\", n[n.MED = 2] = \"MED\", n[n.LOW = 3] = \"LOW\", n[n.MIN = 4] = \"MIN\";\n}(En || (En = {}));\nexport default function (t) {\n  var e = t.children,\n      o = t.options,\n      u = function (n, t) {\n    if (null == n) return {};\n    var r,\n        e,\n        o = {},\n        u = Object.keys(n);\n\n    for (e = 0; e < u.length; e++) t.indexOf(r = u[e]) >= 0 || (o[r] = n[r]);\n\n    return o;\n  }(t, r);\n\n  return n.cloneElement(Ln(e, o), u);\n}\nexport { Ln as compiler };","map":{"version":3,"sources":["../index.tsx"],"names":["ATTRIBUTE_TO_JSX_PROP_MAP","reduce","obj","x","toLowerCase","for","namedCodesToUnicode","amp","apos","gt","lt","nbsp","quot","DO_NOT_PROCESS_HTML_ELEMENTS","ATTR_EXTRACTOR_R","AUTOLINK_MAILTO_CHECK_R","BLOCK_END_R","BLOCKQUOTE_R","BLOCKQUOTE_TRIM_LEFT_MULTILINE_R","BREAK_LINE_R","BREAK_THEMATIC_R","CODE_BLOCK_FENCED_R","CODE_BLOCK_R","CODE_INLINE_R","CONSECUTIVE_NEWLINE_R","CR_NEWLINE_R","FOOTNOTE_R","FOOTNOTE_REFERENCE_R","FORMFEED_R","GFM_TASK_R","HEADING_R","HEADING_SETEXT_R","HTML_BLOCK_ELEMENT_R","HTML_CHAR_CODE_R","HTML_COMMENT_R","HTML_CUSTOM_ATTR_R","HTML_SELF_CLOSING_ELEMENT_R","INTERPOLATION_R","LINK_AUTOLINK_BARE_URL_R","LINK_AUTOLINK_MAILTO_R","LINK_AUTOLINK_R","LIST_ITEM_END_R","LIST_LOOKBEHIND_R","CAPTURE_LETTER_AFTER_HYPHEN","NP_TABLE_R","REFERENCE_IMAGE_OR_LINK","REFERENCE_IMAGE_R","REFERENCE_LINK_R","SQUARE_BRACKETS_R","SHOULD_RENDER_AS_BLOCK_R","TAB_R","TABLE_SEPARATOR_R","TABLE_TRIM_PIPES","TABLE_CELL_END_TRIM","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","TABLE_RIGHT_ALIGN","TEXT_BOLD_R","TEXT_EMPHASIZED_R","TEXT_STRIKETHROUGHED_R","TEXT_ESCAPED_R","TEXT_PLAIN_R","TRIM_STARTING_NEWLINES","HTML_LEFT_TRIM_AMOUNT_R","UNESCAPE_URL_R","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","LIST_R","LINK_INSIDE","LINK_R","IMAGE_R","NON_PARAGRAPH_BLOCK_SYNTAXES","BLOCK_SYNTAXES","input","some","r","test","str","first","length","slice","slugify","replace","parseTableAlignCapture","alignCapture","parseTableRow","source","parse","state","prevInTable","_inTable","tableRow","trim","cells","forEach","node","i","type","push","content","split","map","rowText","parseTable","capture","_inline","header","align","parseTableCells","getTableStyle","colIndex","textAlign","key","indexOf","match","_","letter","toUpperCase","value","styles","kvPair","substr","sanitizeUrl","rules","ruleList","Object","keys","sort","typeA","typeB","orderA","_order","orderB","nestedParse","result","prevCapture","ruleType","rule","_match","currCaptureString","substring","parsed","_parse","normalizeWhitespace","inlineRegex","regex","exec","simpleInlineRegex","_simple","blockRegex","anyScopeRegex","matchParagraph","prevCapturedString","endsWith","every","line","captured","trimEnd","outputFunc","nestedReactOutput","ast","Array","isArray","oldKey","_key","lastWasString","nodeOut","isString","url","decodeURIComponent","e","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","isCurrentlySimple","parseSimpleInline","parseBlock","parseCaptureInline","captureNothing","renderNothing","_react","cx","filter","Boolean","join","get","src","path","fb","ptr","frags","undefined","shift","getTag","tag","overrides","override","Priority","compiler","markdown","options","createElementFn","createElement","React","h","props","overrideProps","className","compile","forceInline","forceBlock","arr","emitter","parser","pop","wrapper","jsx","forceWrapper","attrStringToMap","attributes","raw","index","delimiterIdx","normalizeAttributeKey","unquote","mappedKey","normalizedValue","attributeValueToJSXPropValue","cloneElement","footnotes","refs","blockQuote","HIGH","output","breakLine","__","breakThematic","codeBlock","MAX","lang","codeFenced","codeInline","LOW","footnote","identifier","footnoteReference","target","href","gfmTask","completed","checked","readOnly","heading","id","level","headingSetext","htmlComment","image","alt","title","link","linkAngleBraceStyleDetector","linkBareUrlDetector","_inAnchor","linkMailtoDetector","address","list","isStartOfLine","_list","bullet","ordered","start","items","lastItemWasAParagraph","item","space","spaceRegex","isLastItem","thisItemIsAParagraph","oldStateInline","oldStateList","adjustedContent","newlineCoalescer","paragraph","ref","refImage","refLink","fallbackContent","table","style","row","c","tableSeparator","text","MIN","full","inner","textBolded","MED","textEmphasized","textEscaped","textStrikethroughed","disableParsingRawHTML","htmlBlock","trimmer","trimmed","parseFunc","tagName","noInnerParse","attrs","htmlSelfClosing","parserFor","ruleOutput","def","children"],"mappings":"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","sourcesContent":["/* @jsx h */\n/**\n * markdown-to-jsx is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. 🙏🏼\n */\nimport * as React from 'react'\n\nexport namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  export type CreateElement = typeof React.createElement\n\n  export type HTMLTags = keyof JSX.IntrinsicElements\n\n  export type State = {\n    _inAnchor?: boolean\n    _inline?: boolean\n    _inTable?: boolean\n    _key?: React.Key\n    _list?: boolean\n    _simple?: boolean\n  }\n\n  export type ParserResult = {\n    [key: string]: any\n    type?: string\n  }\n\n  export type NestedParser = (\n    input: string,\n    state?: MarkdownToJSX.State\n  ) => MarkdownToJSX.ParserResult\n\n  export type Parser<ParserOutput> = (\n    capture: RegExpMatchArray,\n    nestedParse: NestedParser,\n    state?: MarkdownToJSX.State\n  ) => ParserOutput\n\n  export type RuleOutput = (\n    ast: MarkdownToJSX.ParserResult,\n    state: MarkdownToJSX.State\n  ) => JSX.Element\n\n  export type Rule<ParserOutput = MarkdownToJSX.ParserResult> = {\n    _match: (\n      source: string,\n      state: MarkdownToJSX.State,\n      prevCapturedString?: string\n    ) => RegExpMatchArray\n    _order: Priority\n    _parse: MarkdownToJSX.Parser<ParserOutput>\n    _react?: (\n      node: ParserOutput,\n      output: RuleOutput,\n      state?: MarkdownToJSX.State\n    ) => React.ReactChild\n  }\n\n  export type Rules = {\n    [key: string]: Rule\n  }\n\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.Props<any>,\n      ...children: React.ReactChild[]\n    ) => JSX.Element\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     */\n    forceInline: boolean\n\n    /**\n     * Supply additional HTML entity: unicode replacement mappings.\n     *\n     * Pass only the inner part of the entity as the key,\n     * e.g. `&le;` -> `{ \"le\": \"\\u2264\" }`\n     *\n     * By default\n     * the following entites are replaced with their unicode equivalents:\n     *\n     * ```\n     * &amp;\n     * &apos;\n     * &gt;\n     * &lt;\n     * &nbsp;\n     * &quot;\n     * ```\n     */\n    namedCodesToUnicode: {\n      [key: string]: string\n    }\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     */\n    overrides: Overrides\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     */\n    wrapper: React.ElementType | null\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     */\n    forceWrapper: boolean\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     */\n    slugify: (source: string) => string\n  }>\n}\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = [\n  'allowFullScreen',\n  'allowTransparency',\n  'autoComplete',\n  'autoFocus',\n  'autoPlay',\n  'cellPadding',\n  'cellSpacing',\n  'charSet',\n  'className',\n  'classId',\n  'colSpan',\n  'contentEditable',\n  'contextMenu',\n  'crossOrigin',\n  'encType',\n  'formAction',\n  'formEncType',\n  'formMethod',\n  'formNoValidate',\n  'formTarget',\n  'frameBorder',\n  'hrefLang',\n  'inputMode',\n  'keyParams',\n  'keyType',\n  'marginHeight',\n  'marginWidth',\n  'maxLength',\n  'mediaGroup',\n  'minLength',\n  'noValidate',\n  'radioGroup',\n  'readOnly',\n  'rowSpan',\n  'spellCheck',\n  'srcDoc',\n  'srcLang',\n  'srcSet',\n  'tabIndex',\n  'useMap',\n].reduce((obj, x) => ((obj[x.toLowerCase()] = x), obj), { for: 'htmlFor' })\n\nconst namedCodesToUnicode = {\n  amp: '\\u0026',\n  apos: '\\u0027',\n  gt: '\\u003e',\n  lt: '\\u003c',\n  nbsp: '\\u00a0',\n  quot: '\\u201c',\n} as const\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script']\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ↳ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ↓                ↳ disabled: true\n *                     ↳ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ↳ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R =\n  /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i\nconst BLOCK_END_R = /\\n{2,}$/\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm\nconst BREAK_LINE_R = /^ {2,}\\n/\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/\nconst CODE_BLOCK_FENCED_R =\n  /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/\nconst CR_NEWLINE_R = /\\r\\n?/g\nconst FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/\nconst FORMFEED_R = /\\f/g\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+?)(?: +#*)?(?:\\n *)*(?:\\n|$)/\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R =\n  /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i\n\nconst HTML_CHAR_CODE_R = /&([a-z]+);/g\n\nconst HTML_COMMENT_R = /^<!--[\\s\\S]*?(?:-->)/\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/\n\nconst HTML_SELF_CLOSING_ELEMENT_R =\n  /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i\nconst INTERPOLATION_R = /^\\{.*\\}$/\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/\nconst LIST_ITEM_END_R = / *\\n+$/\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/\nconst PARAGRAPH_R = /^[^\\n]+(?:  \\n|\\n{2,})/\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst SQUARE_BRACKETS_R = /(\\[|\\])/g\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\nconst TAB_R = /\\t/g\nconst TABLE_SEPARATOR_R = /^ *\\| */\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g\nconst TABLE_CELL_END_TRIM = / *$/\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/\n\nconst TEXT_BOLD_R =\n  /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/\nconst TEXT_EMPHASIZED_R =\n  /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1|\\w)/\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/\nconst TEXT_PLAIN_R =\n  /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i\n\nconst TRIM_STARTING_NEWLINES = /^\\n+/\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)'\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +'\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX)\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n  '^' +\n    LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' )[^\\\\n]*)*(\\\\n|$)',\n  'gm'\n)\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n  '^( *)(' +\n    LIST_BULLET +\n    ') ' +\n    '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' (?!' +\n    LIST_BULLET +\n    ' ))\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\\\n*$)'\n)\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*'\nconst LINK_HREF_AND_TITLE =\n  '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*'\n\nconst LINK_R = new RegExp(\n  '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst IMAGE_R = new RegExp(\n  '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst NON_PARAGRAPH_BLOCK_SYNTAXES = [\n  BLOCKQUOTE_R,\n  CODE_BLOCK_R,\n  CODE_BLOCK_FENCED_R,\n  HEADING_R,\n  HEADING_SETEXT_R,\n  HTML_COMMENT_R,\n  LIST_ITEM_R,\n  LIST_R,\n  NP_TABLE_R,\n]\n\nconst BLOCK_SYNTAXES = [\n  ...NON_PARAGRAPH_BLOCK_SYNTAXES,\n  PARAGRAPH_R,\n  HTML_BLOCK_ELEMENT_R,\n  HTML_SELF_CLOSING_ELEMENT_R,\n]\n\nfunction containsBlockSyntax(input: string) {\n  return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n/** Remove symmetrical leading and trailing quotes */\nfunction unquote(str: string) {\n  const first = str[0]\n  if (\n    (first === '\"' || first === \"'\") &&\n    str.length >= 2 &&\n    str[str.length - 1] === first\n  ) {\n    return str.slice(1, -1)\n  }\n  return str\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str: string) {\n  return str\n    .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a')\n    .replace(/[çÇ]/g, 'c')\n    .replace(/[ðÐ]/g, 'd')\n    .replace(/[ÈÉÊËéèêë]/g, 'e')\n    .replace(/[ÏïÎîÍíÌì]/g, 'i')\n    .replace(/[Ññ]/g, 'n')\n    .replace(/[øØœŒÕõÔôÓóÒò]/g, 'o')\n    .replace(/[ÜüÛûÚúÙù]/g, 'u')\n    .replace(/[ŸÿÝý]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase()\n}\n\nfunction parseTableAlignCapture(alignCapture: string) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right'\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center'\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left'\n  }\n\n  return null\n}\n\nfunction parseTableRow(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const prevInTable = state._inTable\n  state._inTable = true\n  const tableRow = parse(source.trim(), state)\n  state._inTable = prevInTable\n\n  let cells = [[]]\n  tableRow.forEach(function (node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([])\n      }\n    } else {\n      if (\n        node.type === 'text' &&\n        (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')\n      ) {\n        node.content = node.content.replace(TABLE_CELL_END_TRIM, '')\n      }\n      cells[cells.length - 1].push(node)\n    }\n  })\n  return cells\n}\n\nfunction parseTableAlign(source: string /*, parse, state*/) {\n  const alignText = source.replace(TABLE_TRIM_PIPES, '').split('|')\n\n  return alignText.map(parseTableAlignCapture)\n}\n\nfunction parseTableCells(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const rowsText = source.trim().split('\\n')\n\n  return rowsText.map(function (rowText) {\n    return parseTableRow(rowText, parse, state)\n  })\n}\n\nfunction parseTable(\n  capture: RegExpMatchArray,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  state._inline = true\n  const header = parseTableRow(capture[1], parse, state)\n  const align = parseTableAlign(capture[2])\n  const cells = parseTableCells(capture[3], parse, state)\n  state._inline = false\n\n  return {\n    align: align,\n    cells: cells,\n    header: header,\n    type: 'table',\n  }\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node.align[colIndex] == null\n    ? {}\n    : {\n        textAlign: node.align[colIndex],\n      }\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n  const hyphenIndex = key.indexOf('-')\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function (_, letter) {\n      return letter.toUpperCase()\n    })\n  }\n\n  return key\n}\n\nfunction attributeValueToJSXPropValue(\n  key: JSX.IntrinsicAttributes,\n  value: string\n): any {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function (styles, kvPair) {\n      const key = kvPair.slice(0, kvPair.indexOf(':'))\n\n      // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n      const camelCasedKey = key.replace(/(-[a-z])/g, substr =>\n        substr[1].toUpperCase()\n      )\n\n      // key.length + 1 to skip over the colon\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim()\n\n      return styles\n    }, {})\n  } else if (key === 'href') {\n    return sanitizeUrl(value)\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1)\n  }\n\n  if (value === 'true') {\n    return true\n  } else if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n\nfunction normalizeWhitespace(source: string): string {\n  return source\n    .replace(CR_NEWLINE_R, '\\n')\n    .replace(FORMFEED_R, '')\n    .replace(TAB_R, '    ')\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(\n  rules: MarkdownToJSX.Rules\n): (\n  source: string,\n  state: MarkdownToJSX.State\n) => ReturnType<MarkdownToJSX.NestedParser> {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  let ruleList = Object.keys(rules)\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function (type) {\n      let order = rules[type]._order\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (typeof order !== 'number' || !isFinite(order))\n      ) {\n        console.warn(\n          'markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order\n        )\n      }\n    })\n  }\n\n  ruleList.sort(function (typeA, typeB) {\n    let orderA = rules[typeA]._order\n    let orderB = rules[typeB]._order\n\n    // First sort based on increasing order\n    if (orderA !== orderB) {\n      return orderA - orderB\n\n      // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1\n    }\n\n    return 1\n  })\n\n  function nestedParse(\n    source: string,\n    state: MarkdownToJSX.State\n  ): MarkdownToJSX.ParserResult[] {\n    let result = []\n\n    // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n    let prevCapture = ''\n    while (source) {\n      let i = 0\n      while (i < ruleList.length) {\n        const ruleType = ruleList[i]\n        const rule = rules[ruleType]\n        const capture = rule._match(source, state, prevCapture)\n\n        if (capture) {\n          const currCaptureString = capture[0]\n          source = source.substring(currCaptureString.length)\n          const parsed = rule._parse(capture, nestedParse, state)\n\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType\n          }\n\n          result.push(parsed)\n\n          prevCapture = currCaptureString\n          break\n        }\n\n        i++\n      }\n    }\n\n    return result\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state)\n  }\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex(regex: RegExp) {\n  return function match(source, state: MarkdownToJSX.State) {\n    if (state._inline) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state._inline || state._simple) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state._inline || state._simple) {\n      return null\n    } else {\n      return regex.exec(source)\n    }\n  }\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex(regex: RegExp) {\n  return function match(source: string /*, state*/) {\n    return regex.exec(source)\n  }\n}\n\nfunction matchParagraph(\n  source: string,\n  state: MarkdownToJSX.State,\n  prevCapturedString?: string\n) {\n  if (state._inline || state._simple) {\n    return null\n  }\n\n  if (prevCapturedString && !prevCapturedString.endsWith('\\n')) {\n    // don't match continuation of a line\n    return null\n  }\n\n  let match = ''\n\n  source.split('\\n').every(line => {\n    // bail out on first sign of non-paragraph block\n    if (NON_PARAGRAPH_BLOCK_SYNTAXES.some(regex => regex.test(line))) {\n      return false\n    }\n    match += line + '\\n'\n    return line.trim()\n  })\n\n  const captured = match.trimEnd()\n  if (captured == '') {\n    return null\n  }\n\n  return [match, captured]\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(\n    ast: MarkdownToJSX.ParserResult | MarkdownToJSX.ParserResult[],\n    state: MarkdownToJSX.State = {}\n  ): React.ReactChild[] {\n    if (Array.isArray(ast)) {\n      const oldKey = state._key\n      const result = []\n\n      // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n      let lastWasString = false\n\n      for (let i = 0; i < ast.length; i++) {\n        state._key = i\n\n        const nodeOut = nestedReactOutput(ast[i], state)\n        const isString = typeof nodeOut === 'string'\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut\n        } else if (nodeOut !== null) {\n          result.push(nodeOut)\n        }\n\n        lastWasString = isString\n      }\n\n      state._key = oldKey\n\n      return result\n    }\n\n    return outputFunc(ast, nestedReactOutput, state)\n  }\n}\n\nfunction sanitizeUrl(url: string): string | null {\n  try {\n    const decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '')\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        url\n      )\n    }\n\n    // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n    return null\n  }\n\n  return url\n}\n\nfunction unescapeUrl(rawUrlString: string): string {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1')\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state._inline || false\n  const isCurrentlySimple = state._simple || false\n  state._inline = true\n  state._simple = true\n  const result = parse(content, state)\n  state._inline = isCurrentlyInline\n  state._simple = isCurrentlySimple\n  return result\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state._inline || false\n  const isCurrentlySimple = state._simple || false\n  state._inline = false\n  state._simple = true\n  const result = parse(content, state)\n  state._inline = isCurrentlyInline\n  state._simple = isCurrentlySimple\n  return result\n}\n\nfunction parseBlock(\n  parse,\n  content,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  state._inline = false\n  return parse(content + '\\n\\n', state)\n}\n\nconst parseCaptureInline: MarkdownToJSX.Parser<ReturnType<typeof parseInline>> =\n  (capture, parse, state: MarkdownToJSX.State) => {\n    return {\n      content: parseInline(parse, capture[1], state),\n    }\n  }\n\nfunction captureNothing() {\n  return {}\n}\n\nfunction renderNothing() {\n  return null\n}\n\nfunction ruleOutput(rules: MarkdownToJSX.Rules) {\n  return function nestedRuleOutput(\n    ast: MarkdownToJSX.ParserResult,\n    outputFunc: MarkdownToJSX.RuleOutput,\n    state: MarkdownToJSX.State\n  ): React.ReactChild {\n    return rules[ast.type]._react(ast, outputFunc, state)\n  }\n}\n\nfunction cx(...args) {\n  return args.filter(Boolean).join(' ')\n}\n\nfunction get(src: Object, path: string, fb?: any) {\n  let ptr = src\n  const frags = path.split('.')\n\n  while (frags.length) {\n    ptr = ptr[frags[0]]\n\n    if (ptr === undefined) break\n    else frags.shift()\n  }\n\n  return ptr || fb\n}\n\nfunction getTag(tag: string, overrides: MarkdownToJSX.Overrides) {\n  const override = get(overrides, tag)\n\n  if (!override) return tag\n\n  return typeof override === 'function' ||\n    (typeof override === 'object' && 'render' in override)\n    ? override\n    : get(overrides, `${tag}.component`, tag)\n}\n\nenum Priority {\n  /**\n   * anything that must scan the tree before everything else\n   */\n  MAX,\n  /**\n   * scans for block-level constructs\n   */\n  HIGH,\n  /**\n   * inline w/ more priority than other inline\n   */\n  MED,\n  /**\n   * inline elements\n   */\n  LOW,\n  /**\n   * bare text and stuff that is considered leftovers\n   */\n  MIN,\n}\n\nexport function compiler(\n  markdown: string,\n  options: MarkdownToJSX.Options = {}\n) {\n  options.overrides = options.overrides || {}\n  options.slugify = options.slugify || slugify\n  options.namedCodesToUnicode = options.namedCodesToUnicode\n    ? { ...namedCodesToUnicode, ...options.namedCodesToUnicode }\n    : namedCodesToUnicode\n\n  const createElementFn = options.createElement || React.createElement\n\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(options.overrides, `${tag}.props`, {})\n\n    return createElementFn(\n      getTag(tag, options.overrides),\n      {\n        ...props,\n        ...overrideProps,\n        className: cx(props?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  function compile(input: string): JSX.Element {\n    let _inline = false\n\n    if (options.forceInline) {\n      _inline = true\n    } else if (!options.forceBlock) {\n      /**\n       * should not contain any block-level markdown like newlines, lists, headings,\n       * thematic breaks, blockquotes, tables, etc\n       */\n      _inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false\n    }\n\n    const arr = emitter(\n      parser(\n        _inline\n          ? input\n          : `${input.trimEnd().replace(TRIM_STARTING_NEWLINES, '')}\\n\\n`,\n        {\n          _inline,\n        }\n      )\n    )\n\n    while (\n      typeof arr[arr.length - 1] === 'string' &&\n      !arr[arr.length - 1].trim()\n    ) {\n      arr.pop()\n    }\n\n    if (options.wrapper === null) {\n      return arr\n    }\n\n    const wrapper = options.wrapper || (_inline ? 'span' : 'div')\n    let jsx\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr\n    } else if (arr.length === 1) {\n      jsx = arr[0]\n\n      // TODO: remove this for React 16\n      if (typeof jsx === 'string') {\n        return <span key=\"outer\">{jsx}</span>\n      } else {\n        return jsx\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null\n    }\n\n    return React.createElement(wrapper, { key: 'outer' }, jsx)\n  }\n\n  function attrStringToMap(str: string): React.Props<any> {\n    const attributes = str.match(ATTR_EXTRACTOR_R)\n\n    return attributes\n      ? attributes.reduce(function (map, raw, index) {\n          const delimiterIdx = raw.indexOf('=')\n\n          if (delimiterIdx !== -1) {\n            const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim()\n            const value = unquote(raw.slice(delimiterIdx + 1).trim())\n\n            const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key\n            const normalizedValue = (map[mappedKey] =\n              attributeValueToJSXPropValue(key, value))\n\n            if (\n              typeof normalizedValue === 'string' &&\n              (HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n                HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))\n            ) {\n              map[mappedKey] = React.cloneElement(\n                compile(normalizedValue.trim()),\n                { key: index }\n              )\n            }\n          } else if (raw !== 'style') {\n            map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true\n          }\n\n          return map\n        }, {})\n      : undefined\n  }\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (\n      Object.prototype.toString.call(options.overrides) !== '[object Object]'\n    ) {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const footnotes: { footnote: string; identifier: string }[] = []\n  const refs: { [key: string]: { target: string; title: string } } = {}\n\n  /**\n   * each rule's react() output function goes through our custom h() JSX pragma;\n   * this allows the override functionality to be automatically applied\n   */\n  const rules: MarkdownToJSX.Rules = {\n    blockQuote: {\n      _match: blockRegex(BLOCKQUOTE_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        return {\n          content: parse(\n            capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''),\n            state\n          ),\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <blockquote key={state._key}>\n            {output(node.content, state)}\n          </blockquote>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: MarkdownToJSX.ParserResult }>,\n\n    breakLine: {\n      _match: anyScopeRegex(BREAK_LINE_R),\n      _order: Priority.HIGH,\n      _parse: captureNothing,\n      _react(_, __, state) {\n        return <br key={state._key} />\n      },\n    },\n\n    breakThematic: {\n      _match: blockRegex(BREAK_THEMATIC_R),\n      _order: Priority.HIGH,\n      _parse: captureNothing,\n      _react(_, __, state) {\n        return <hr key={state._key} />\n      },\n    },\n\n    codeBlock: {\n      _match: blockRegex(CODE_BLOCK_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          lang: undefined,\n        }\n      },\n\n      _react(node, output, state) {\n        return (\n          <pre key={state._key}>\n            <code className={node.lang ? `lang-${node.lang}` : ''}>\n              {node.content}\n            </code>\n          </pre>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; lang?: string }>,\n\n    codeFenced: {\n      _match: blockRegex(CODE_BLOCK_FENCED_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: capture[3],\n          lang: capture[2] || undefined,\n          type: 'codeBlock',\n        }\n      },\n    },\n\n    codeInline: {\n      _match: simpleInlineRegex(CODE_INLINE_R),\n      _order: Priority.LOW,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return <code key={state._key}>{node.content}</code>\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    /**\n     * footnotes are emitted at the end of compilation in a special <footer> block\n     */\n    footnote: {\n      _match: blockRegex(FOOTNOTE_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        footnotes.push({\n          footnote: capture[2],\n          identifier: capture[1],\n        })\n\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    footnoteReference: {\n      _match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse*/) {\n        return {\n          content: capture[1],\n          target: `#${options.slugify(capture[1])}`,\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <a key={state._key} href={sanitizeUrl(node.target)}>\n            <sup key={state._key}>{node.content}</sup>\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; target: string }>,\n\n    gfmTask: {\n      _match: inlineRegex(GFM_TASK_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          completed: capture[1].toLowerCase() === 'x',\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <input\n            checked={node.completed}\n            key={state._key}\n            readOnly\n            type=\"checkbox\"\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ completed: boolean }>,\n\n    heading: {\n      _match: blockRegex(HEADING_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[2], state),\n          id: options.slugify(capture[2]),\n          level: capture[1].length,\n        }\n      },\n      _react(node, output, state) {\n        node.tag = `h${node.level}` as MarkdownToJSX.HTMLTags\n        return (\n          <node.tag id={node.id} key={state._key}>\n            {output(node.content, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      id: string\n      level: number\n      tag: MarkdownToJSX.HTMLTags\n    }>,\n\n    headingSetext: {\n      _match: blockRegex(HEADING_SETEXT_R),\n      _order: Priority.MAX,\n      _parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[1], state),\n          level: capture[2] === '=' ? 1 : 2,\n          type: 'heading',\n        }\n      },\n    },\n\n    htmlComment: {\n      _match: anyScopeRegex(HTML_COMMENT_R),\n      _order: Priority.HIGH,\n      _parse() {\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    image: {\n      _match: simpleInlineRegex(IMAGE_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <img\n            key={state._key}\n            alt={node.alt || undefined}\n            title={node.title || undefined}\n            src={sanitizeUrl(node.target)}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; target: string; title?: string }>,\n\n    link: {\n      _match: inlineRegex(LINK_R),\n      _order: Priority.LOW,\n      _parse(capture, parse, state) {\n        return {\n          content: parseSimpleInline(parse, capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <a\n            key={state._key}\n            href={sanitizeUrl(node.target)}\n            title={node.title}\n          >\n            {output(node.content, state)}\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      target: string\n      title?: string\n    }>,\n\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      _match: inlineRegex(LINK_AUTOLINK_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          type: 'link',\n        }\n      },\n    },\n\n    linkBareUrlDetector: {\n      _match: (source, state) => {\n        if (state._inAnchor) {\n          return null\n        }\n        return inlineRegex(LINK_AUTOLINK_BARE_URL_R)(source, state)\n      },\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          title: undefined,\n          type: 'link',\n        }\n      },\n    },\n\n    linkMailtoDetector: {\n      _match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      _order: Priority.MAX,\n      _parse(capture /*, parse, state*/) {\n        let address = capture[1]\n        let target = capture[1]\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target\n        }\n\n        return {\n          content: [\n            {\n              content: address.replace('mailto:', ''),\n              type: 'text',\n            },\n          ],\n          target: target,\n          type: 'link',\n        }\n      },\n    },\n\n    list: {\n      _match(source, state, prevCapture) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture)\n        const isListBlock = state._list || !state._inline\n\n        if (isStartOfLine && isListBlock) {\n          source = isStartOfLine[1] + source\n\n          return LIST_R.exec(source)\n        } else {\n          return null\n        }\n      },\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        const bullet = capture[2]\n        const ordered = bullet.length > 1\n        const start = ordered ? +bullet : undefined\n        const items = capture[0]\n          // recognize the end of a paragraph block inside a list item:\n          // two or more newlines at end end of the item\n          .replace(BLOCK_END_R, '\\n')\n          .match(LIST_ITEM_R)\n\n        let lastItemWasAParagraph = false\n        const itemContent = items.map(function (item, i) {\n          // We need to see how far indented the item is:\n          const space = LIST_ITEM_PREFIX_R.exec(item)[0].length\n\n          // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n          const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm')\n\n          // Before processing the item, we need a couple things\n          const content = item\n            // remove indents on trailing lines:\n            .replace(spaceRegex, '')\n            // remove the bullet:\n            .replace(LIST_ITEM_PREFIX_R, '')\n\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n          const isLastItem = i === items.length - 1\n          const containsBlocks = content.indexOf('\\n\\n') !== -1\n\n          // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n          const thisItemIsAParagraph =\n            containsBlocks || (isLastItem && lastItemWasAParagraph)\n          lastItemWasAParagraph = thisItemIsAParagraph\n\n          // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state._inline depending\n          // on our list's looseness.\n          const oldStateInline = state._inline\n          const oldStateList = state._list\n          state._list = true\n\n          // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n          let adjustedContent\n          if (thisItemIsAParagraph) {\n            state._inline = false\n            adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n')\n          } else {\n            state._inline = true\n            adjustedContent = content.replace(LIST_ITEM_END_R, '')\n          }\n\n          const result = parse(adjustedContent, state)\n\n          // Restore our state before returning\n          state._inline = oldStateInline\n          state._list = oldStateList\n\n          return result\n        })\n\n        return {\n          items: itemContent,\n          ordered: ordered,\n          start: start,\n        }\n      },\n      _react(node, output, state) {\n        const Tag = node.ordered ? 'ol' : 'ul'\n\n        return (\n          <Tag key={state._key} start={node.start}>\n            {node.items.map(function generateListItem(item, i) {\n              return <li key={i}>{output(item, state)}</li>\n            })}\n          </Tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      items: MarkdownToJSX.ParserResult[]\n      ordered: boolean\n      start?: number\n    }>,\n\n    newlineCoalescer: {\n      _match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      _order: Priority.LOW,\n      _parse: captureNothing,\n      _react(/*node, output, state*/) {\n        return '\\n'\n      },\n    },\n\n    paragraph: {\n      _match: matchParagraph,\n      _order: Priority.LOW,\n      _parse: parseCaptureInline,\n      _react(node, output, state) {\n        return <p key={state._key}>{output(node.content, state)}</p>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ref: {\n      _match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      _order: Priority.MAX,\n      _parse(capture /*, parse*/) {\n        refs[capture[1]] = {\n          target: capture[2],\n          title: capture[4],\n        }\n\n        return {}\n      },\n      _react: renderNothing,\n    },\n\n    refImage: {\n      _match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      _order: Priority.MAX,\n      _parse(capture) {\n        return {\n          alt: capture[1] || undefined,\n          ref: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          <img\n            key={state._key}\n            alt={node.alt}\n            src={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; ref: string }>,\n\n    refLink: {\n      _match: inlineRegex(REFERENCE_LINK_R),\n      _order: Priority.MAX,\n      _parse(capture, parse, state) {\n        return {\n          content: parse(capture[1], state),\n          fallbackContent: parse(\n            capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'),\n            state\n          ),\n          ref: capture[2],\n        }\n      },\n      _react(node, output, state) {\n        return refs[node.ref] ? (\n          <a\n            key={state._key}\n            href={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          >\n            {output(node.content, state)}\n          </a>\n        ) : (\n          <span key={state._key}>{output(node.fallbackContent, state)}</span>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      fallbackContent: MarkdownToJSX.ParserResult\n      ref: string\n    }>,\n\n    table: {\n      _match: blockRegex(NP_TABLE_R),\n      _order: Priority.HIGH,\n      _parse: parseTable,\n      _react(node, output, state) {\n        return (\n          <table key={state._key}>\n            <thead>\n              <tr>\n                {node.header.map(function generateHeaderCell(content, i) {\n                  return (\n                    <th key={i} style={getTableStyle(node, i)}>\n                      {output(content, state)}\n                    </th>\n                  )\n                })}\n              </tr>\n            </thead>\n\n            <tbody>\n              {node.cells.map(function generateTableRow(row, i) {\n                return (\n                  <tr key={i}>\n                    {row.map(function generateTableCell(content, c) {\n                      return (\n                        <td key={c} style={getTableStyle(node, c)}>\n                          {output(content, state)}\n                        </td>\n                      )\n                    })}\n                  </tr>\n                )\n              })}\n            </tbody>\n          </table>\n        )\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseTable>>,\n\n    tableSeparator: {\n      _match: function (source, state) {\n        if (!state._inTable) {\n          return null\n        }\n        return TABLE_SEPARATOR_R.exec(source)\n      },\n      _order: Priority.HIGH,\n      _parse: function () {\n        return { type: 'tableSeparator' }\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      _react() {\n        return ' | '\n      },\n    },\n\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      _match: anyScopeRegex(TEXT_PLAIN_R),\n      _order: Priority.MIN,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0]\n            // nbsp -> unicode equivalent for named chars\n            .replace(HTML_CHAR_CODE_R, (full, inner) => {\n              return options.namedCodesToUnicode[inner]\n                ? options.namedCodesToUnicode[inner]\n                : full\n            }),\n        }\n      },\n      _react(node /*, output, state*/) {\n        return node.content\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    textBolded: {\n      _match: simpleInlineRegex(TEXT_BOLD_R),\n      _order: Priority.MED,\n      _parse(capture, parse, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      _react(node, output, state) {\n        return <strong key={state._key}>{output(node.content, state)}</strong>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEmphasized: {\n      _match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      _order: Priority.LOW,\n      _parse(capture, parse, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      _react(node, output, state) {\n        return <em key={state._key}>{output(node.content, state)}</em>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      _match: simpleInlineRegex(TEXT_ESCAPED_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          content: capture[1],\n          type: 'text',\n        }\n      },\n    },\n\n    textStrikethroughed: {\n      _match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      _order: Priority.LOW,\n      _parse: parseCaptureInline,\n      _react(node, output, state) {\n        return <del key={state._key}>{output(node.content, state)}</del>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n  }\n\n  // Object.keys(rules).forEach(key => {\n  //     let { match, parse } = rules[key];\n\n  //     rules[key]._match = (...args) => {\n  //         const start = performance.now();\n  //         const result = match(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(\n  //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n  //                     args[0]\n  //                 }`\n  //             );\n\n  //         return result;\n  //     };\n\n  //     rules[key]._parse = (...args) => {\n  //         const start = performance.now();\n  //         const result = parse(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n\n  //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n\n  //         return result;\n  //     };\n  // });\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      _match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      _order: Priority.HIGH,\n      _parse(capture, parse, state) {\n        const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n        const trimmer = new RegExp(`^${whitespace}`, 'gm')\n        const trimmed = capture[3].replace(trimmer, '')\n\n        const parseFunc = containsBlockSyntax(trimmed)\n          ? parseBlock\n          : parseInline\n\n        const tagName = capture[1].toLowerCase() as MarkdownToJSX.HTMLTags\n        const noInnerParse =\n          DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(tagName) !== -1\n\n        state._inAnchor = state._inAnchor || tagName === 'a'\n\n        /**\n         * if another html block is detected within, parse as block,\n         * otherwise parse as inline to pick up any further markdown\n         */\n        const content = noInnerParse\n          ? capture[3]\n          : parseFunc(parse, trimmed, state)\n\n        state._inAnchor = false\n\n        return {\n          attrs: attrStringToMap(capture[2]),\n          content,\n\n          noInnerParse,\n\n          tag: noInnerParse ? tagName : capture[1],\n        }\n      },\n      _react(node, output, state) {\n        return (\n          // @ts-ignore\n          <node.tag key={state._key} {...node.attrs}>\n            {node.noInnerParse\n              ? (node.content as string)\n              : output(node.content as MarkdownToJSX.ParserResult, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      content: string | ReturnType<MarkdownToJSX.NestedParser>\n      noInnerParse: Boolean\n      tag: string\n    }>\n\n    rules.htmlSelfClosing = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      _match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      _order: Priority.HIGH,\n      _parse(capture /*, parse, state*/) {\n        return {\n          attrs: attrStringToMap(capture[2] || ''),\n          tag: capture[1],\n        }\n      },\n      _react(node, output, state) {\n        return <node.tag {...node.attrs} key={state._key} />\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      tag: string\n    }>\n  }\n\n  const parser = parserFor(rules)\n  const emitter: Function = reactFor(ruleOutput(rules))\n\n  const jsx = compile(markdown)\n\n  if (footnotes.length) {\n    return (\n      <div>\n        {jsx}\n        <footer key=\"footer\">\n          {footnotes.map(function createFootnote(def) {\n            return (\n              <div id={options.slugify(def.identifier)} key={def.identifier}>\n                {def.identifier}\n                {emitter(parser(def.footnote, { _inline: true }))}\n              </div>\n            )\n          })}\n        </footer>\n      </div>\n    )\n  }\n\n  return jsx\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n */\nconst Markdown: React.FC<{\n  [key: string]: any\n  children: string\n  options?: MarkdownToJSX.Options\n}> = ({ children, options, ...props }) => {\n  return React.cloneElement(\n    compiler(children, options),\n    props as React.Props<any>\n  )\n}\n\nexport default Markdown\n"]},"metadata":{},"sourceType":"module"}